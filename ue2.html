<html>
    <head>
        <meta charset="utf-8" />
        <title></title>
        <link rel="stylesheet" type="text/css" href="format.css">
        <style type="text/css">
            <!--
            a:link {font-family:Arial;        font-size:10pt;        text-decoration:none;}
            a:visited {font-family:Arial; font-size:10pt; text-decoration:none;}
            a:hover {color:#FF3333; text-decoration:none; font-weight:normal; font-size:10pt;}
            //-->
        </style>
    </head>

    <body>

        <iframe src="oben.html" width="800" height="120" name="IFrame3" id="IFrame3" scrolling="no" frameborder="0">
            <p>Ihr Browser kann leider keine eingebe5tteten Frames anzeigen:Sie k&ouml;nnen die eingebettete Seite &uuml;ber den
                folgenden.</p>
        </iframe>

        <h2>Übung 2</h2>
        <br><h3>Aufgabe 1</h3>
        <h4>
            Erzeuge zwei Bilder im Format 16x9 mit deiner Kamera oder deinem Handy (960x540 Pixel, 24Bit), davon eines mit eher flächigen Inhalten (Gang/Decke/Wand/Schrank) und eines
            mit feineren Strukturen (Natur) und achte auf gute Belichtung. <br><br>

            Benenne die Dateien "Flaechen_NameArbeitsgruppe.bmp" und Details_NameArbeitsgruppe.bmp". Schick mir die beiden BMP-Dateien unter Nennung deiner Arbeitsgruppe per Mail.
            Darauf werde ich dir zwei BMP-Dateien mit Testbildern zusenden, die du bei den folgenden Aufgabenpunkten benötigst, gratingHXX.bmp und gratingVXX.bmp.

        </h4>
        <p>Lösung</p>
        <table>
            <tr>
                <td><img src="./pics/Details_Monoton.bmp" alt="Detailbild" width="300">
                    <br> Detailbild mit Baumrinde.
                </td>
                <td>
                    <img src="./pics/Flaechen_Monoton.bmp" alt="Flächenbild" width="300">
                    <br> Flächenbild mit Wand.
                </td>
            </tr>
            <tr>
                <td><img src="./pics/grating_H4.bmp" alt="Vertikale Linien" width="300">
                    <br> Zugesandtes Testbild mit vertikalen Linien
                </td>
                <td>
                    <img src="./pics/grating_V4.bmp" alt="Horizontale Linien" width="300">
                    <br> Zugesandtes Testbild mit horizontalen Linien
                </td>
            </tr>
        </table>
        <br><h3>Aufgabe 2 - 2.1</h3>
        <h4> Modifiziere bmp_io dahingehend, dass die RGB Werte der einzeln
            en Pixel in der BMP-D
            atei in eine (lesbare) ASCII-Datei geschri
            eben werden. Es reichen dabei jeweils eine
            Zeile und eine Spalte! Lies die
            von mir geschickten Testdateien ein und schätze aus den result
            ierenden Zahlenfolgen die Period
            endauer in Pixeln in horizontaler und vertikaler
            Richtung. (Jeweils eine Periode horizontal und eine vertikal für das Übungsprotokoll abspeichern).</h4>
        <p>Lösung</p>
        <img src="./pics/asciiH4.png" alt="Screenshot der Textdatei für H4" width="454" height="287">
        <img src="./pics/asciiV4.png" alt="Screenshot der Textdatei für V4" width="454" height="287">
        <p>Beschreibung</p>
        <p>Beispielhafter Code für das Schreiben der x-Werte. Gleiches für y.</p>
        <section class="code">for (int x = 0; x < bmp.image.getWidth(); x++) {
            <p style="text-indent:20px;">int r = bmp.image.getRgbPixel(x, 0).r;
            <p style="text-indent:20px;">int g = bmp.image.getRgbPixel(x, 0).g;
            <p style="text-indent:20px;">int b = bmp.image.getRgbPixel(x, 0).b;
            <p style="text-indent:20px;">String rgb = "x" + x + " (" + b + "|" + g + "|" + r + ")";
            <p style="text-indent:20px;">ascii.write(rgb);
            <p style="text-indent:20px;">ascii.newLine();</p>
            }</section>
        <p>Lösung</p>
        Schaut man sich die beiden Ascii-Textdatein an (Bild 1 für H4 und Bild 2 für V4)
        kann man die Perioden durch die Zahlengrößen schon erahnen.<br>
        <br> Die markierten Bereiche in den Bildern stellen 2 Perioden da.
        Zählt man diese durch, erkennt man, für grating_H4 eine horizontale Periodendauer von etwa 13 - 14 sec.
        Das gleiche für grating_V4 in vertikaler Richtung von etwa 5 - 6 sec.

        <br><h3>Aufgabe 2 - 2.2</h3>
        <h4> Auch bei der Bildabtastung muss das sogenannte Abtasttheorem eingehalten werden. Wie lautet es und wie läßt sich der Grenzfall, für den es gerade noch gilt, illustrieren
            (Zeichnung !)?</h4>
        <p>Lösung</p>
        Das Abtasttheorem besagt, dass man etwas mehr als eine doppelt so hohe Abtastrate benötigen, wie mein abgetastetes Bild.<br>
        <br>Theoretisch reicht hier auch eine genau doppelt so hohe Abstastrate, die jedoch in einem Grenzfall zu Schwierigkeiten führen kann.
        Dieser Grenzfall besteht darin, dass mein abzutastenes Bild aus abwechselnd schwarzen und weißen Pixeln besteht.
        Hier kann es passieren, dass bei genau doppelt so hoher Abtastrate, immer nur die schwarzen oder weißen Pixel treffen und somit der Wechsel verloren geht.
        Um dies zu vermeiden, sollte die Abtastrate etwas höher angesetzt werden.
        <br><br>Um diesen Grenzfall zu verdeutlichen, eine Bespielhafte Darstellung:
        <br>
        <img src="./pics/abtastung.jpg" alt="Skizze für den Grenzfall." width="454" height="287">

        <br><h3>Aufgabe 2 - 2.3</h3>
        <h4> Erzeuge
            aus deinen eigenen Farbbildern Graustufen-Bilder. Dazu muss der Helligkeitswert Y aus
            den RGB-Werten errechnet werden. Es gibt dafür verschiedene Ansätze.
            Nutze die Formel Y= 0,3 x R + 0,6 x G + 0,1 x B, die die Helligkeitsempfindlichkeit des Auges annähert.
            Mit diesem Y-Wert wird dann die R, G und B-Information überschrieben.
            Speichere die Graustufenbilder ab.</h4>
        <p>Lösung</p>
        <img src="./pics/Details_Monoton.bmp" alt="Screenshot der Textdatei für H4" width="454" height="287">
        <img src="./pics/Details_Monoton_out.bmp" alt="Screenshot der Textdatei für H4" width="454" height="287">
        <br>
        <img src="./pics/Flaechen_Monoton.bmp" alt="Screenshot der Textdatei für H4" width="454" height="287">
        <img src="./pics/Flaechen_Monoton.bmp_out.bmp" alt="Screenshot der Textdatei für H4" width="454" height="287"><br><br>
        Wie man sieht, sind trotz totalem Farbverlustes, die Struktur und die Details im Graustufenbild weiterhin vorhanden. Für die Warnehmung eines Bildes sind weniger die Farbwerte und Intesitäten von Bedeutung, als die Übergänge von Hell auf Dunkel.
        <br>
        <br>
        <section class="code">for(int y = 0; y < bmp.image.getHeight(); y++) {
            <p style="text-indent:20px;">for(int x = 0;x < bmp.image.getWidth(); x++) {
            <p style="text-indent:40px;">int r = bmp.image.getRgbPixel(x, y).r;
            <p style="text-indent:40px;">int g = bmp.image.getRgbPixel(x, y).g;
            <p style="text-indent:40px;">int b = bmp.image.getRgbPixel(x, y).b;
            <p style="text-indent:40px;">double Y = 0.3 * r + 0.6 * g + 0.1 * b;
            <p style="text-indent:40px;">int intY = (int) Y;
            <p style="text-indent:40px;">PixelColor pixelColor = new PixelColor(intY, intY, intY);
            <p style="text-indent:40px;">bmp.image.setRgbPixel(x, y, pixelColor);
            <p style="text-indent:20px;">}<P>}</P>
        </section>

        <br><h3>Aufgabe 2 - 2.4</h3>
        <h4> Erkläre, wie bei
            Bild- und Videoaufnahmen
            Aliasing entstehen kann. Ähnlich wie bei der 1. Übung am Audiosignal wird auf das Bild ein Down-Sampling anwenwandt und sehen, wann dabei Aliasing auftritt. Beim Audiosignal ist jedes zweite Sample verworfen und damit die Abtastfrequenz halbiert. Beim Bild verringern wird die räumliche
            Auflösung, indem wir die Zahl der Bildzeilen bzw. Bildspalten verringern. Dabei wollen wir das Bild allerdings nicht verkleinern - was normalerweise die Folge wäre - sondern einfach
            die ungeradzahligen Spalten durch den Inhalt der geradzahligen
            Spalten ersetzen, d.h. Spalte 1 wird durch Spalte 0 ersetzt, Spalte 3 durch Spalte 2 etc. und analog für die Zeilen.
            Wenn das Ursprungsbild nun sehr feine Strukturen aufweist, wie in machen Testdateien, können Aliasing-Verzerrungen sichtbar werden. Achte darauf, dass stets Rot, Grün und
            Blau getrennt manipuliert werden müssen.</h4>
        <p>Lösung</p>
        <img src="./pics/grating_H4_down.bmp" alt="Screenshot der Textdatei für H4" width="454" height="287">
        <img src="./pics/grating_V4_down.bmp" alt="Screenshot der Textdatei für H4" width="454" height="287">
        <br><br>Bei der Bildbearbeitung kann es zu räumlichen Aliasing kommen. Dies geschiet, wenn die Feinheit des Abtastrasters nicht ausreichend ist.
        <br>Dadurch können schnelle hell/dunkel-Wechsel nicht richtig abgebildet werden und es kommt zu einem sogenannten Moiré-Effekt.
        <br>Die eigentlich schnelle Veränderung von hell zu dunkel (und umgekehrt) verlangsamt sich, wodurch der in den Bilder zu erkennende unerwünschte Effekt auftritt.
        <br>Um dies zu verhindern, muss eine höhere DPI oder Framerate verwendet werden. Das muss bei unser manipulation von einzelnen Pixeln direkt mit berücksichtigt werden.
<!-- i am Here for now  -->
        <br><h3>Aufgabe 2 - 2.5</h3>
        <h4> Modifiziere bmp_io dahingehend, dass zunächst in jeder Zeile des eingelesenen Bilds jedes ungeradzahlige Pixel durch das davor liegende geradzahlige Pixel ersetzt wird
            (horizontales Down-Sampling).
            Diese Veränderung hat natürlich nur bei einem der beiden Testbilder Sinn (warum?). Speichere das resultierende Bild ab. Da sich die Bildgröße bei
            dieser Operation nicht ändert, muss der Bild-Header auch nicht verändert werden. Falls du im Ergebnis keine Veränderung sehen
            kannst, ersetze mehr Spalten, also Spalte 1 und 2
            durch Spalte 0, dann Spalte 1, 2
            und 3 durch Spalte 0 usw. Wende diese Manipulation auf die Testbilder an, bis du eine Veränderung in Form eines Moiré-Musters siehst. Notiere,
            bei welcher Verringerung du die Veränderungen beobachtest und beschreibe die Veränderungen! Erkläre das Ergebnis an Hand der von dir bestimmten Periodendauer in Pixeln.
            Nun wende die Zeilenverringerung vertikal an, d.h. ersetze die
            Pixel jeder ungeradzahligen Zeile durch die der Zeile davor (vertikales Down-Sampling). Auch hier hat die
            Manipulation nur bei einer der Testdateien Sinn!
            Abschließend wendest du noch das horizontale Downsampling auf deine eigenen Bilder an, bis du eine sichtbare Verschlechterung beobachtest. Notiere auch hier, wann dies beideinen beiden Bildern der Fall ist.</h4>
        <p>Lösung</p>
        <img src="./pics/grating_H4.bmp" alt="Screenshot der Textdatei für H4" width="454" height="287">
        <img src="./pics/grating_H4_down.bmp" alt="Grating H4 Down-Sampling" width="454" height="287">
        <br><br>Das horizontale Downsampling macht nur bei dem Bild grating_H4.bmp Sinn, da es im Gegensatz zu grating_V4.bmp eine horizontale Veränderung der Pixel aufweist. Bei V4, wären nur Pixel der gleichen Farbe ausgetauscht worden, wodurch keine Veränderung sichtbar wäre.
        <br>Ein deutlicher Effekt wurde bei einer Verringerung von 7 px sichtbar.
        <br>Man erkennt, dass an bestimmten Stellen der schnelle Übergang zwischen schwarzen und weißen Stellen verlangsamt wird und dadurch gräuliche Flächen entstehen.
        <br><br>
        <img src="./pics/grating_V4.bmp" alt="Screenshot der Textdatei für H4" width="454" height="287">
        <img src="./pics/grating_V4_down.bmp" alt="Grating V4 Down-Sampling" width="454" height="287">
        <br><br>Das vertikale Downsampling macht auch hier nur bei dem anderen Bild grating_V4.bmp Sinn, da im Gegensatz zu grating_H4.bmp eine vertikale Veränderung der Pixel stattfindet. Bei H4, wären nur Pixel der gleichen Farbe ausgetauscht worden, wodurch keine Veränderung sichtbar wäre.
        <br>Ein deutlicher Effekt wurde hier schon bei einer Verringerung von 3 px sichtbar, was durch die viel höhere Anzahl an bearbeitbaren Pixeln erklärbar ist. (kürzere Periodendauer)
        <br>Man erkennt auch hier, dass an bestimmten Stellen der schnelle Übergang zwischen schwarzen und weißen Stellen verlangsamt wird und dadurch gräuliche Flächen entstehen. Es ist schon fast mit einem Wellen-Muster zu vergleichen.
        <br><br>
        <img src="./pics/Flaechen_Monoton.bmp" alt="Flächen Down-Sampling" width="454" height="287">
        <img src="./pics/Flaechen_Monoton_down.bmp" alt="Flächen Down-Sampling" width="454" height="287">
        <br>
        <img src="./pics/Details_Monoton.bmp" alt="Flächen Down-Sampling" width="454" height="287">
        <img src="./pics/Details_Monoton_down.bmp" alt="Details Down-Sampling" width="454" height="287">
        <br><br>Bei unseren eigenen Bildern verwendeten wir eine horizontale Verringerung der Pixel von 3.
        <br>Deutlich wird dies in den Details des Baumes oder der Fenster über der Wand. Bei Flächen mit geringen Helligkeitsunterschieden, ist das Downsampling kaum zu merken.<br>
        Sobald wir starke und regelmäßige Helligkeitsunterschiede haben, beginnt das Downsampling wahrnehmbare Aliasingeffekte sichtbar zu machen.
        <br>
        <br>Der unten stehende Code behandelt das horizontale Downsampling:
        <section class="code">int mod = 5;<br>
            for(int y = 0; y < bmp.image.getHeight(); y++) {
            <p style="text-indent:20px;">PixelColor pixelColor = null;
            <p style="text-indent:20px;">for(int x = 0; x < bmp.image.getWidth(); x++) {
            <p style="text-indent:40px;">if (!(y%mod == 0) && y > 0){
            <p style="text-indent:60px;">pixelColor = bmp.image.getRgbPixel(x, y - 1);
            <p style="text-indent:60px;">bmp.image.setRgbPixel(x, y, pixelColor);
            <p style="text-indent:20px;">}<br>}
        </section>
        <br>
        <br>Der unten stehende Code behandelt das vertikale Downsampling:
        <section class="code">int mod = 5;<br>
            for(int y = 0; y < bmp.image.getHeight(); y++) {
            <p style="text-indent:20px;">PixelColor pixelColor = null;
            <p style="text-indent:20px;">for(int x = 0; x < bmp.image.getWidth(); x++) {
            <p style="text-indent:40px;">if (!(x%mod == 0) && x > 0){
            <p style="text-indent:60px;">pixelColor = bmp.image.getRgbPixel(x - 1, y);
            <p style="text-indent:60px;">bmp.image.setRgbPixel(x, y, pixelColor);
            <p style="text-indent:20px;">}<br>}
        </section>
        <!-- Beginn Aufgabe 3 ----------------------------------------------------------------------------------------------- -->
        <br><h2>Aufgabe 3 - Bitreduzierung</h2>
        <hr color="#444444" size="2">

        <br><h4>Aufgabe 3.1</h4>
        <h4>Überlegung: </h4>
        <p class="QnA">
            Die wird bmp_io so modifizieren, dass die Bitzahl reduziert werden kann. Dazu können werden z.B.
            alle RGB-Werte durch eine Potenz von 2 geiteilt (Integer-Division ohne Rest). Damit das resultierende Bild nicht
            dunkler wird als das Original, wird die Operation durch Multiplikation mit derselben Zweierpotenz kompensiert.
        </p>

        <h4>Folgender Code wurde für die Bitreduzierung verwendet:</h4>

        <section class="code">
            <code>
                <div class="code1">int reduced_bits = 3;</div>
                <div class="code1">for(int y = 0; y < bmp.image.getHeight(); y++) {</div>
                <div class="code2">for (int x = 0; x < bmp.image.getWidth(); x++) {</div>
                <div class="code2">&nbsp int pixelR = bmp.image.getRgbPixel(x, y).r / (int) Math.pow(2, reduced_bits)*(int) Math.pow(2, reduced_bits);</div>
                <div class="code2">&nbsp int pixelG = bmp.image.getRgbPixel(x, y).g/ (int) Math.pow(2, reduced_bits)*(int) Math.pow(2, reduced_bits);</div>
                <div class="code2">&nbsp int pixelB = bmp.image.getRgbPixel(x, y).b/ (int) Math.pow(2, reduced_bits)*(int) Math.pow(2, reduced_bits);</div>
                <div class="code2">&nbsp PixelColor reducedPixel = new PixelColor(pixelB, pixelG, pixelR);</div>
                <div class="code2">&nbsp bmp.image.setRgbPixel(x, y, reducedPixel);</div>
                <div class="code1">&nbsp &nbsp }</div>
                <div class="code1">}</div>
            </code>
        </section>
        <br>

        <h4>Aufgabe 3.2</h4>
        <h4>Frage: </h4>
        <p class="QnA">
            Mit dem entstandenen Programm verändern wir die in Aufgabe 1 erzeugten BMP-Dateien.
            Ab welcher Bitzahl tritt beim Detail-Bild und beim Flächen-Bild eine sichtbare Verschlechterung der Qualität ein?
            Wie kann man diese Verschlechterung am besten beschreiben?
        </p>

        <h4>Lösung: </h4>
        <P>Detailbild Original
            <br><img src="./pics/Details_Monoton.bmp" alt="Detail_Monoton_original" width="640" height="362">
            <br><br>Detailbild 4 Bit-reduziert
            <br><img src="./pics/Details_Monoton_4bitRed.bmp" alt="Detail_Monoton_4bitReduziert" width="640" height="362">
            <br><br>Detailbild 6 Bit-reduziert
            <br><img src="./pics/Details_Monoton_6bitRed.bmp" alt="Detail_Monoton_6bitReduziert" width="640" height="362">
            <br><br>Detailbild 7 Bit-reduziert
            <br><img src="./pics/Details_Monoton_7bitRed.bmp" alt="Detail_Monoton_7bitReduziert" width="640" height="362">
            <br>
            <br>Beim Detailbild tritt erst bei einer 6-Bit-Reduzierung eine sofort sichtbare, und ab einer 7-Bit-Reduzierung eine deutliche
            Verschlechterung der Qualität ein. Die Schattierungen, die durch die Feinheiten des Objekts geworfen werden, und auch allgemein die
            Details des Objektes sind weniger sichtbar. Viel mehr sieht man, dass die Grenzen von Farbton zu Farbton (insbesondere hell-dunkel-Übergänge)
            sehr viel schärfer gezogen werden und die einzelnen Farbflächen dadurch vergrößert werden (dunkle, vorher detailreiche Bereiche
            werden flächig schwarz).
            <br>Diesen Effekt sieht man verdeutlicht am Flächenbild:
            <br>
            <br>Flächenbild original
            <br><img src="./pics/Flaechen_Monoton.bmp" alt="Flaechen_Monoton_original" width="640" height="360">
            <br><br>Flächenbild 3-Bit-reduziert
            <br><img src="./pics/Flaechen_Monoton_3bitRed.bmp" alt="Flaechen_Monoton_3bitreduziert" width="640" height="360">
            <br><br>Flächenbild 4-Bit-reduziert
            <br><img src="./pics/Flaechen_Monoton_4bitRed.bmp" alt="Flaechen_Monoton_4bitreduziert" width="640" height="360">
            <br><br>Flächenbild 6-Bit-reduziert
            <br><img src="./pics/Flaechen_Monoton_6bitRed.bmp" alt="Flaechen_Monoton_6bitreduziert" width="640" height="360">
            <br><br>Flächenbild 7-Bit-reduziert
            <br><img src="./pics/Flaechen_Monoton_7bitRed.bmp" alt="Flaechen_Monoton_7bitreduziert" width="640" height="360">
            <br>
            <br> Hier beginnt man bereits bei der 3-Bit-Reduzierung im rechten Bereich die Einfärbung ähnlicher Farben auf dem Holz zu sehen. Bei der 4-Bit-Reduzierung
            ist der Qualitätsverlust bereits deutlich zu sehen. Da dieses Bild keine detailreichen Bereiche hat, sind hier "schattigere" Bereiche
            großflächig in einer Farbe abgebildet. Bei 6 oder gar 7 Bit ist nicht mehr zu erkennen, was auf dem Originalbild zu sehen war. Nur im
            oberen Bereich des Bildes, wo die Glasquader mit Gitterstruktur zu sehen sind, kann man noch Details erkennen. Dies liegt daran, dass
            dort wieder eine scharfe Abgrenzung zwischen hell und dunkel haben, wohingegen im unteren Bereich die Flächen im Original eine recht
            gleichmäßige Farbstruktur aufwiesen.
            <br><br>Was steckt dahinter? Durch die Bitreduzierung gehen Informationen des Originalbildes verloren, und zwar die Informationen, die in den least significant Bits stecken. Durch das Teilen und folgende Multiplizieren mit der Zweierpotenz wird der Wert dieser least significant Bits auf 0 gesetzt. In der gesamten Bitzahl von 8 sind diese Reduzierungen jedoch sehr gering. Besonders in den feineren Farb- bzw. Helligkeitsübergängen sieht man den Detailverlust: die Oberflächen mit ähnlichen Farben werden nun durch eine Farbe dargestellt.
            <br>Der Verlust der Informationen der least significant Bits ist besonders bei dunkleren Farben zu sehen, dass die Farbe schwarz den RGB Wert (0,0,0) hat. Bei dunkleren Farben sind also auch niedrigere most significant Bits. Durch den Verlust der least significant Bits bleibt als Gesamtwert eine sehr niedrige Zahl übrig. Das Resultat ist ein großflächig dunkler, beinahe schwarzer Bereich.
        </p>


        <h4>Aufgabe 3.3</h4>
        <h4>Aufgabe: </h4>
        <p class="QnA">
            Modifiziere dein Programm noch einmal so, dass auch das Differenzbild zwischen Original und bitreduziertem Bild, das heißt das
            Fehlerbild ausgegeben, werden kann. Beachte dabei, dass bei der Differenzbildung negative und positive Werte auftreten können.
            Diese müssen wieder in den Wertebereich 0...255 transformiert werden, d.h. auf den Mittelwert 127 gebracht werden (wie?).
            Dabei musst du auch bedenken, dass z.B. bei 1 Bit Reduzierung der Fehler nur 0, 1 oder -1 wäre. Dieser Wertebereich wäre viel zu
            klein, als dass man ihn in der 8bit-Grafik noch sehen könnte. Daher muss der Fehler durch Multiplikation mit einer 2er Potenz
            verstärkt werden. In anderen Worten: Hat man vorher durch 2^n geteilt, sollte man das Differenzsignal vor dem Abspeichern mit
            2^(8-n-1) multiplizieren. So ist sichergestellt, dass der Verstärkungsfaktor mit der Anzahl der gelöschten Bits kleiner wird.
        </p>

        <h4>Code, der das Differenzbild erzeugt: </h4>
        <section class="code">
            <code>
                <div class="code1">int reduced_bits = 7;</div>
                <div class="code1">int bitsPerColor = 8;</div>
                <div class="code1">int gainFactor = (int) Math.pow( 2, bitsPerColor - reduced_bits - 1  );</div>
                <div class="code1">int powerOfTwo = (int) Math.pow(2, reduced_bits);</div>
                <div class="code1">for(int y = 0; y < bmp.image.getHeight(); y++) {</div>
                <div class="code2">&nbsp for (int x = 0; x < bmp.image.getWidth(); x++) {</div>
                <div class="code2">&nbsp &nbsp PixelColor p = bmp.image.getRgbPixel(x, y);</div>
                <div class="code2">&nbsp &nbsp int r = (p.r - (p.r / powerOfTwo)* powerOfTwo) * gainFactor + 128;</div>
                <div class="code2">&nbsp &nbsp int b = (p.b - (p.b / powerOfTwo)* powerOfTwo) * gainFactor + 128;</div>
                <div class="code2">&nbsp &nbsp int g = (p.g - (p.g / powerOfTwo)* powerOfTwo) * gainFactor+ 128;</div>
                <div class="code2">&nbsp &nbsp bmp.image.setRgbPixel(x, y, new PixelColor(r, g, b));</div>
                <div class="code2">&nbsp}</div>
                <div class="code1">}</div>
            </code>
        </section>

        <h4>Ergebnisse und Interpretation</h4>
        <table>
            <tr>
                <td><img src="./pics/Details_Monoton_diff1.bmp" alt="Detailbild 1 Bit Differenzbild" width="150"><br> 1 Bit Differenzbild</td>
                <td><img src="./pics/Details_Monoton_diff3.bmp" alt="Detailbild 3 Bit Differenzbild" width="150"><br> 3 Bit Differenzbild</td>
                <td><img src="./pics/Details_Monoton_diff5.bmp" alt="Detailbild 5 Bit Differenzbild" width="150"><br> 5 Bit Differenzbild</td>
                <td><img src="./pics/Details_Monoton_diff7.bmp" alt="Detailbild 7 Bit Differenzbild" width="150"><br> 7 Bit Differenzbild</td>
            </tr>
        </table>
         <table>
            <tr>
                <td><img src="./pics/Flaechen_Monoton_diff1.bmp" alt="Flächenbild 1 Bit Differenzbild" width="150"><br> 1 Bit Differenzbild</td>
                <td><img src="./pics/Flaechen_Monoton_diff3.bmp" alt="Flächenbild 3 Bit Differenzbild" width="150"><br> 3 Bit Differenzbild</td>
                <td><img src="./pics/Flaechen_Monoton_diff5.bmp" alt="Flächenbild 5 Bit Differenzbild" width="150"><br> 5 Bit Differenzbild</td>
                <td><img src="./pics/Flaechen_Monoton_diff7.bmp" alt="Flächenbild 7 Bit Differenzbild" width="150"><br> 7 Bit Differenzbild</td>
            </tr>
        </table>

        <br><br> Bei der Differenzbildung erhält ein Bild aus den Informationen, die bei der Bitreduzierung verloren geht.
        Wie in der vorangegangenen Aufgabe dargestellt werden konnte, ist die Auswirkung der Bitreduzierung dort besonders stark, wo kleine Farbunterschiede vorhanden sind.
        Diese feinen Farbunterschiede gehen mit steiegender Bitreduzierung verloren. Dies wird durch die berechneten Differenzbilder bestätigt.
        Das flächige Bild, welches in der vorherigen Aufgabe früher als das Detailbild sichtbare Veränderungen aufzeigte, lässt in seinen Differenzbildern ebenfalls bereits bei
        geringeren Reduzierungen Formen und Strukturen erkennen.
        </body>
</html>
